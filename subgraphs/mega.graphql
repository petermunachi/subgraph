type DelegatedWallet @entity {
  " authoriser-delegate "
  id: ID!
  authoriser: Bytes!
  delegate: Bytes!
  canMint: Boolean
  canBurn: Boolean
  canClaim: Boolean
  canExchange: Boolean
}
type ExchangeEntrySettled @entity {
  " transaction hash and log index "
  id: ID!

  " synth exchanged from "
  from: Bytes!

  " synth exchanged to "
  src: Bytes!

  " number of units of synth from exchanged "
  amount: BigDecimal!

  " address which receives the settlement "
  dest: Bytes!

  " amount reclaimed of dest due to underpayment "
  reclaim: BigDecimal!

  " amount returned of dest due to overpayment "
  rebate: BigDecimal!

  " aggregator price round for src synth "
  srcRoundIdAtPeriodEnd: BigInt!

  " aggregator price round for dest synth "
  destRoundIdAtPeriodEnd: BigInt!

  " time when the original exchange occured "
  exchangeTimestamp: BigInt!
}

type ExchangeEntryAppended @entity {
  " transaction hash and log index "
  id: ID! # the transaction hash plus event log
  " ethereum address which funded the exchange "
  account: Bytes!

  " synth exchanged from "
  src: Bytes!

  " number of units of synth from exchanged "
  amount: BigDecimal!

  " synth exchanged to "
  dest: Bytes!

  " number of units of synth to received "
  amountReceived: BigDecimal!

  " fee paid in sUSD to the synthetix fee pool "
  exchangeFeeRate: BigDecimal!

  " aggregator price round for src synth "
  roundIdForSrc: BigInt!

  " aggregator price round for dest synth "
  roundIdForDest: BigInt!
}

type TemporaryExchangePartnerTracker @entity {
  " Transaction hash of the Exchange event "
  id: ID!

  " Total transaction volume in USD across all ExchangeEntryAppended events in a single tx hash "
  usdVolume: BigDecimal

  " Total fees from this transaction hash "
  usdFees: BigDecimal

  " String format of the tracking code for a given partner "
  partner: String
}

type DailyExchangePartner @entity {
  " Day timestamp + tracking code of the partner "
  id: ID!

  " Total transaction volume in USD for the partner on this day "
  usdVolume: BigDecimal!

  " Total fees generated by the volume partner for this day "
  usdFees: BigDecimal!

  " Total number of trades from the volume partner for this day "
  trades: BigInt!

  " Tracking code of the partner "
  partner: String!

  " unix timestamp at the beginning of the day "
  timestamp: BigInt!
}

type ExchangePartner @entity {
  " Tracking code of the partner "
  id: ID!

  " Total transaction volume in USD for the partner "
  usdVolume: BigDecimal!

  " Total fees generated by the volume partner "
  usdFees: BigDecimal!

  " Total number of trades from the volume partner "
  trades: BigInt!
}

# Synthentix is an aggregation entity
# Total synth exchanges in aggregate
type Total @entity {
  " 'mainnet' always "
  id: ID!

  " number of trades completed over period "
  trades: BigInt!

  " number of unique traders seen over period "
  exchangers: BigInt!

  " synth value exchanged in USD units "
  exchangeUSDTally: BigDecimal!

  " synth value received in fees in USD units "
  totalFeesGeneratedInUSD: BigDecimal!
}

type PostArchernarTotal @entity {
  " 'mainnet' always "
  id: ID!

  " number of trades completed over period "
  trades: BigInt!

  " number of unique traders seen over period "
  exchangers: BigInt!

  " synth value exchanged in USD units "
  exchangeUSDTally: BigDecimal!

  " synth value received in fees in USD units "
  totalFeesGeneratedInUSD: BigDecimal!
}

# Total synth exchanges per day
type DailyTotal @entity {
  " numeric, incrementing timestamp "
  id: ID!

  " timestamp of the beginning of the day this represents "
  timestamp: BigInt!

  " number of trades completed over period "
  trades: BigInt!

  " number of unique traders seen over period "
  exchangers: BigInt!

  " synth value exchanged in USD units "
  exchangeUSDTally: BigDecimal!

  " synth value received in fees in USD units "
  totalFeesGeneratedInUSD: BigDecimal!
}

# Total synth exchanges per 15 minute period
type FifteenMinuteTotal @entity {
  " numeric, incrementing time period "
  id: ID!

  " timestamp of the beginning of the period this represents "
  timestamp: BigInt!

  " number of trades completed over period "
  trades: BigInt!

  " number of unique traders seen over period "
  exchangers: BigInt!

  " synth value exchanged in USD units "
  exchangeUSDTally: BigDecimal!

  " synth value received in fees in USD units "
  totalFeesGeneratedInUSD: BigDecimal!
}

" Tracks this event from the Synthetix.sol contract "
type SynthExchange @entity {
  id: ID!
  account: Bytes! # address
  from: Bytes! # address
  fromCurrencyKey: Bytes! # bytes4
  fromSynth: String! # human readable from synth name
  fromAmount: BigDecimal! # uint256
  fromAmountInUSD: BigDecimal! # from Amount including fees
  toCurrencyKey: Bytes! # bytes4
  toSynth: String! # human readable to synth name
  toAmount: BigDecimal! # uint256
  toAmountInUSD: BigDecimal! # to Amount without fees
  feesInUSD: BigDecimal!
  toAddress: Bytes! # address
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

" Tracks this event from the Synthetix.sol contract "
type ExchangeReclaim @entity {
  id: ID!
  account: Bytes! # address
  currencyKey: Bytes! # bytes4
  amount: BigDecimal! # uint256
  amountInUSD: BigDecimal! # uint256
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

" Tracks this event from the Synthetix.sol contract "
type ExchangeRebate @entity {
  id: ID!
  account: Bytes! # address
  currencyKey: Bytes! # bytes4
  amount: BigDecimal! # uint256
  amountInUSD: BigDecimal! # uint256
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

" An individual Exchanger "
type Exchanger @entity {
  id: ID!
}

" An individual Exchanger Post Archernar "
type PostArchernarExchanger @entity {
  id: ID!
}

" An individual Exchanger seen during a day "
type DailyExchanger @entity {
  id: ID!
}

" An individual Exchanger seen during a fifteen minute period "
type FifteenMinuteExchanger @entity {
  id: ID!
}

type ExchangeFee @entity {
  " Name of the synth. E.g. sUSD "
  id: ID!

  " Current Fee as a ratio of the trade amount "
  fee: BigDecimal!
}

type DebtState @entity {
  " Global historical debt entry index "
  id: ID!

  " time at which these values are recorded "
  timestamp: BigInt!

  " representation of total amount of debt issued over time. increases or decreases proportionally whenever synths are minted/burned "
  debtEntry: BigDecimal!

  " current value of all issued synths which this debt pool is responsible for. fluctuates based on the synth breakdown of the system * exchange rates "
  totalIssuedSynths: BigDecimal!

  " totalIssuedSynths / debtEntry - useful for tracking debt over time "
  debtRatio: BigDecimal!
}
" Synthentix is an aggregation entity "
type Synthetix @entity {
  id: ID!

  " number of stakers currently staking "
  issuers: BigInt!

  " number of addresses which hold SNX "
  snxHolders: BigInt!
}

" An individual Issuer "
type Issuer @entity {
  id: ID!
}

" An individual SNX holder (always overridden with their latest information) "
type SNXHolder @entity {
  " address of holder "
  id: ID!

  " last block where an event happened "
  block: BigInt!

  " last time where an event happened "
  timestamp: BigInt!

  " current SNX balance of the holder "
  balanceOf: BigDecimal

  # the following will be null before multicurrency (v2) release
  " SNX which is being used for collateral as of last event and cannot be spent "
  collateral: BigDecimal

  " SNX which can be spent as of last event "
  transferable: BigDecimal

  initialDebtOwnership: BigInt

  debtEntryAtIndex: BigInt

  " number of claims performed "
  claims: BigInt

  " number of mints performed "
  mints: BigInt
}

" A historical debt tracker "
type DebtSnapshot @entity {
  id: ID!

  " last block where an event happened "
  block: BigInt!

  " last time when an event happened "
  timestamp: BigInt!

  " address for which these statistics are applicable "
  account: Bytes! # address
  balanceOf: BigDecimal # early on it was possible this wouldn't have a value (pre v2)
  # the following will be null before multicurrency (v2) release

  " SNX which is being used for collateral as of last event and cannot be spent "
  collateral: BigDecimal

  " sUSD of debt as of last event "
  debtBalanceOf: BigDecimal
}

type SynthHolder @entity {
  " address of the holder + the synth "
  id: ID!

  " currencyKey of the synth "
  synth: String!

  " units of the synth held in wei "
  balanceOf: BigDecimal!
}

type DailyIssued @entity {
  " unix timestamp at beginning of day of the measurement "
  id: ID!

  " amount issued "
  value: BigDecimal!

  " amount of debt as of the last event for this day "
  totalDebt: BigDecimal!
}

type DailyBurned @entity {
  " unix timestamp at beginning of day of the measurement "
  id: ID!

  " amount burned "
  value: BigDecimal!

  " amount of debt as of the last event for this day "
  totalDebt: BigDecimal!
}

" Tracks this event from various Synth.sol instances "
type Issued @entity {
  id: ID!
  account: Bytes! # address
  value: BigDecimal!
  source: String!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

" Burned tracks this event from various Synth.sol instances "
type Burned @entity {
  id: ID!
  account: Bytes! # address
  value: BigDecimal! # uint256
  source: String!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

type RewardEscrowHolder @entity {
  " address which holds a rewardescrow "
  id: ID!

  " amount of tokens remaining to be claimed from the escrow "
  balanceOf: BigDecimal!

  " amount of SNX claimed from the escrow "
  vestedBalanceOf: BigDecimal!
}

" Tracks this event from Synthetix.sol "
type FeesClaimed @entity {
  id: ID!
  account: Bytes! # address
  value: BigDecimal! # uint256
  rewards: BigDecimal! # uint256
  block: BigInt!
  timestamp: BigInt!
}

type TotalActiveStaker @entity {
  " single value "
  id: ID!

  " number of stakers seen "
  count: BigInt!
}

type TotalDailyActiveStaker @entity {
  " unix timestamp at beginning of day relevant to this statistic "
  id: ID!

  " unix timestamp as a BigInt (so it can be filtered) "
  timestamp: BigInt!

  " number of stakers seen on this day "
  count: BigInt!
}

type ActiveStaker @entity {
  id: ID!
}
type AccountFlaggedForLiquidation @entity {
  " the deadline plus the staker address "
  id: ID!

  " the address of the staker "
  account: Bytes!

  " liqudation deadline "
  deadline: BigInt!

  " current collateral ratio "
  collateralRatio: BigInt!

  " snx that is liquidatable "
  liquidatableNonEscrowSNX: BigDecimal!

  " total collateral held by the staker including escrow amount "
  collateral: BigDecimal!
}

type AccountRemovedFromLiquidation @entity {
  " the time at which the staker fixed their c-ratio plus the staker address "
  id: ID!

  " the address of the staker "
  account: Bytes!

  " the time at which the staker fixed their c-ratio "
  time: BigInt!
}

type AccountLiquidated @entity {
  id: ID!

  "the liquidated address"
  account: Bytes!

  "the amount of SNX redeemed by the liquidator"
  snxRedeemed: BigDecimal!

  "the amount of sUSD liquidated"
  amountLiquidated: BigDecimal!

  "the address liquidating the account"
  liquidator: Bytes!

  "the time at which the liquidation occurred"
  time: BigInt!
}
type Loan @entity {
  " the loan id "
  id: ID!

  " the transaction hash of the loan "
  txHash: String!

  " the account receiving the loan "
  account: Bytes!

  " the type of collateral minted - sUSD or sETH "
  collateralMinted: String!

  " the amount of the loan "
  amount: BigDecimal!

  " is the loan still open? "
  isOpen: Boolean!

  " the timestamp the loan was created "
  createdAt: BigInt!

  " the timestamp the loan was closed "
  closedAt: BigInt

  " whether the loan has any partial liquidations "
  hasPartialLiquidations: Boolean!
}

type LoanLiquidated @entity {
  " the event tx hash plus event log index "
  id: ID!

  " the loan id "
  loanId: BigInt!

  " the account that created the loan "
  account: Bytes!

  " the account that liquidated the loan "
  liquidator: Bytes!

  " the timestamp the loan was liquidated "
  timestamp: BigInt!
}

type LoanPartiallyLiquidated @entity {
  " the event tx hash plus event log index "
  id: ID!

  " the loan id "
  loanId: BigInt!

  " the account that created the loan "
  account: Bytes!

  " the account that partially liquidated the loan "
  liquidator: Bytes!

  " the amount partially liquidated "
  liquidatedAmount: BigDecimal!

  " the amount partially liquidated plus the liquidation fee "
  liquidatedCollateral: BigDecimal!

  " the timestamp the loan was partially liquidated "
  timestamp: BigInt!
}

type CollateralDeposited @entity {
  " the event tx hash plus event log index "
  id: ID!

  " the amount of collateral deposited "
  collateralAmount: BigDecimal!

  " the total amount of collateral after the deposit is included "
  collateralAfter: BigDecimal!

  " the account that created the loan "
  account: Bytes!

  " the loan id "
  loanId: BigInt!

  " the timestamp collateral was deposited "
  timestamp: BigInt!
}

type CollateralWithdrawn @entity {
  " the event tx hash plus event log index "
  id: ID!

  " the amount of collateral withdrawn "
  amountWithdrawn: BigDecimal!

  " the total amount of collateral after the withdrawal is accounted for "
  collateralAfter: BigDecimal!

  " the account that created the loan "
  account: Bytes!

  " the loan id "
  loanId: BigInt!

  " the timestamp collateral was withdrawn "
  timestamp: BigInt!
}

type LoanRepaid @entity {
  " the event tx hash plus event log index "
  id: ID!

  " the amount of the loan that was repaid " # what is the measurement
  repaidAmount: BigDecimal!

  " the total amount of the loan after the repaid amount is accounted for "
  newLoanAmount: BigDecimal!

  " the account that created the loan "
  account: Bytes!

  " the loan id "
  loanId: BigInt!

  " the timestamp the loan was partially or fully repaid "
  timestamp: BigInt!
}
" Latest Rates over time "
type RateUpdate @entity {
  " <transaction hash>-<currency key> "
  id: ID!

  " currencyKey for which this this rate update applies "
  currencyKey: Bytes!

  " currencyKey expressed as a string "
  synth: String!

  " the rate recorded at this timestamp "
  rate: BigDecimal!

  " the block which this rate was recorded "
  block: BigInt!

  " timestamp of the block in which the rate was recorded "
  timestamp: BigInt!
}

" The average price of SNX over a 15 minute period "
type FifteenMinuteSNXPrice @entity {
  " unix timestamp at beginning of 15 minute period "
  id: ID!

  " number of samples averaged in the period "
  count: BigInt!

  " calculated average price of all the samples "
  averagePrice: BigDecimal!
}

" The average price of SNX over a day "
type DailySNXPrice @entity {
  " unix timestamp at beginning of 15 minute period "
  id: ID!

  " number of samples averaged in the period "
  count: BigInt!

  " calculated average price of all the samples "
  averagePrice: BigDecimal!
}

type DailyCandle @entity {
  " DailyEpoch-Asset. E.g. 18361-sETH "
  id: ID!
  synth: String!
  open: BigDecimal!
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!
  timestamp: BigInt!
}
type Short @entity {
  " the short id "
  id: ID!

  " contract level info for the short position "
  contractData: ShortContract!

  " the transaction hash of the short "
  txHash: String!

  " the account that created the short "
  account: Bytes!

  " the type of collateral locked - sUSD, ETH, renBTC "
  collateralLocked: Bytes!

  " the amount of collateral locked in the short "
  collateralLockedAmount: BigDecimal!

  " the denomination of the loan repayment - sETH, sBTC "
  synthBorrowed: Bytes!

  " the amount owed denominated in the loan repayment synth "
  synthBorrowedAmount: BigDecimal!

  " the timestamp the accrued interest was most recently updated "
  accruedInterestLastUpdateTimestamp: BigInt!

  " is the short still open? "
  isOpen: Boolean!

  " the block the short was created at "
  createdAtBlock: BigInt!

  " the timestamp the short was created "
  createdAt: BigInt!

  " the timestamp the short was closed "
  closedAt: BigInt

  " liquidations that have been made on the short "
  liquidations: [ShortLiquidation!] @derivedFrom(field: "short")

  " collateral deposits and withdrawals that have been made on the short "
  collateralChanges: [ShortCollateralChange!] @derivedFrom(field: "short")

  " loan changes that have been made on the short - increasing or decreasing the short position "
  loanChanges: [ShortLoanChange!]! @derivedFrom(field: "short")
}

type ShortCollateralChange @entity {
  " the event tx hash plus event log index "
  id: ID!

  " denotes if the event was a deposit (true) or withdrawal (false)"
  isDeposit: Boolean!

  " the amount of collateral deposited or withdrawn "
  amount: BigDecimal!

  " the total amount of collateral after the deposit or withdrawal is included "
  collateralAfter: BigDecimal!

  " the respective short "
  short: Short!

  " the timestamp collateral was deposited or withdrawn "
  timestamp: BigInt!

  " the block the collateral was changed "
  blockNumber: BigInt!
}

type ShortLoanChange @entity {
  " the event tx hash plus event log index "
  id: ID!

  " denotes if the event was a repayment (true) or an increase of the loan (false)"
  isRepayment: Boolean!

  " the amount of loan repaid or increased "
  amount: BigDecimal!

  " the total amount of loan due after the repayment or increase is included "
  loanAfter: BigDecimal!

  " the respective short "
  short: Short!

  " the price of the repaid synth in dollars "
  rate: BigDecimal!

  " the timestamp of the loan repayment or increase "
  timestamp: BigInt!

  " the block the short loan was changed "
  blockNumber: BigInt!
}

type ShortLiquidation @entity {
  " the event tx hash plus event log index "
  id: ID!

  " the account that liquidated the loan "
  liquidator: Bytes!

  " determines if the "
  isClosed: Boolean!

  " the amount of the loan that was burned "
  liquidatedAmount: BigDecimal!

  " the amount of the collateral that was taken away from the short owner "
  liquidatedCollateral: BigDecimal!

  " the respective short "
  short: Short!

  " the timestamp of the loan liquidation event "
  timestamp: BigInt!

  " the block of the liquidation event "
  blockNumber: BigInt!
}

type ShortContract @entity {
  " the address of the shorting contract "
  id: ID!

  " a list of shorts attached to each contract "
  shorts: [Short!] @derivedFrom(field: "contractData")

  " a list of changes to contract level data "
  contractUpdates: [ShortContractUpdate!] @derivedFrom(field: "contractData")

  " the min c-ratio for borrowers below which they can be liquidated "
  minCratio: BigInt!

  " the minimum collateral required to open a position "
  minCollateral: BigDecimal!

  " the fee for issuing a short "
  issueFeeRate: BigDecimal!

  " the max number of loans per account "
  maxLoansPerAccount: BigInt!

  " Time in seconds that a user must wait between interacting with a loan. Provides front running and flash loan protection. "
  interactionDelay: BigInt!

  " the manager is a contract that ties the shorting contract in with the rest of the Synthetix protocol "
  manager: Bytes!

  " a boolean that prevents new loans on the contract when false "
  canOpenLoans: Boolean!
}

type ShortContractUpdate @entity {
  " the event tx hash plus event log index "
  id: ID!

  " the field that was changed "
  field: String!

  " the new value of the field in string format "
  value: String!

  " the respective short contract "
  contractData: ShortContract!

  " the timestamp of the contract update event "
  timestamp: BigInt!

  " the block the short contract was udpated at "
  blockNumber: BigInt!
}

type InversePricingInfo @entity {
  " Name of inverse synth. E.g. iETH "
  id: ID!

  " whether or not this inverse synth has been frozen "
  frozen: Boolean!

  " configured upper limit "
  upperLimit: BigDecimal!

  " configured lower limit "
  lowerLimit: BigDecimal!

  " matching price point with long synth "
  entryPoint: BigDecimal!
}

type LatestRate @entity {
  " Name of synth. E.g. sUSD "
  id: ID!

  " Synth USD rate "
  rate: BigDecimal!

  " Address of the aggregator which produces current result "
  aggregator: Bytes!
}
